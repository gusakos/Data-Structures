Εξήγηση του κώδικα:

Κατασκευή της κλάσης ArrayBST. 
Η κλάση αυτή υλοποιεί ενα δένδρο όπως ζητήθηκε στην εκφώνηση, χρησιμοποιώντας ενα πίνακα ακαιρέων για
αποθήκευση της πληροφορίας των κόμβων.

Το ενδιαφέρον κομμάτι της υλοποίησης είναι η δέσμευση ενός καινουριου
κομβου καθώς και η απελευθέρωση του. Αυτό πραγματοποιείται στην κλάση
με τις συναρτήσεις getNextNode() και freeNode(). Οι συναρτήσεις
αυτες ακολουθούν το πρότυπο της εκφώνησης στη λειτουργεία τους. Οι ελεύθερες
θεσεις του πίνακα κόμβων πέρνουν την μορφή λίστας, αξιοποιώντας το τρίτο
πεδίο ([2] RIGHT) για να δειχθεί ο επόμενος, και μια μεταβλητή avail_at που
περιέχει την κεφαλή της λίστας.

Η ανάγνωση πεδίων του κόμβου γίνεται με τις μεθόδους info(), right() και left()
οι οποίες δωθέντος της θέσης του κόμβου στον πίνακα επιστρέφουν το κλειδί,
το δεξί και το αριστερό παιδί αντίστοιχα. Ο χειρισμός κάθε κόμβου γινεται μέσω
της θέσης που καταλαμβάνει στον πίνακα. Ως σύμβαση, η τιμή -1 συμβολίζει τον κενό
δείκτη null. Η τιμή -2 στην θέση LEFT ενός κελιου του πίνακα, συμβολίζει οτι το κελί
αυτό δεν χρησιμοποιείται (αυτό επιτρέπει έλεγχο για double-free απο την freeNode())

Οι βασικές λειτουργίες του δένδρου, συγκεκριμένα η πρόσθεση καινούριου κλειδιού
η αναζήτηση κλειδιου και η διαγραφή κλειδιού, γίνονται απο τις addKey(), findKey()
και deleteKey(). Η αναδρομική υλοποίηση της findKey και της deleteKey, απαιτούσε
την δημιουργία των εσωτερικων συναρτήσεων findKeyNode() και deleteKeyNode(), που
επιτρέπουν να δοθεί όρισμα κόμβου, για την εκτέλεση της λειτουργίας στο υποδένδρο.

Με παρόμοιο τρόπο υλοποιήθηκε και η αναζήτηση τιμων διαστήματος, με την συνάρτηση
searchInorderRange() με την εσωτερικη printInorderNodeRange(). Η πρώτη επιστρέφει
τις τιμές που βρήκε σε ArrayList<Integer>, το οποιό περνάει by reference στην δεύτερη
ωστε αυτή να γεμίσει το ArrayList.

Τέλος, υλοποίησα τις getLeftmost() και getRightmost() οι οποίες βρίσκουν τον πιο δεξιο
και πιο αριστερο κομβο του υποδέντρου με ρίζα τον δοθέντο κόμβο. Οι συναρτήσεις επιστρέφουν
και τον πατέρα του κόμβου που βρήκαν indirectly, περνώντας όρισμα int[1] by reference.

:
Με χρήση κληρονομικότητας απο την ArrayBST, κατασκεύασα την ArrayThreadedBST,
η οποία προσθέτει την λειτουργία των threads στο δένδρο της προηγούμενης.

Στον πίνακα πρόσθεσα δυο ακόμη πεδία, που δείχνουν αν το δεξι, η αριστερο
παιδί ειναι thread. Για αυτό κατασκεύασα τους getters/setters left_thread(),
right_thread(), set_left_thread(), get_rigth_thread(), για χειρισμό των πεδιων 
αυτών, αλλα και τις right_anything() και left_anything() οι οποίες επιστρέφουν
την τιμη LEFT/RIGHT ακόμη και οταν πρόκειται για threads [σε αντιθεση με τις right()
και left()].

Επίσης, πρόσθεσα τις συναρτήσεις inorderSucc() και inorderPred()
για την ευρεση του επόμενου και του προηγούμενο inorder κομβου,
με εκμετάλευση των threads και την βοήθεια των συναρτήσεων get[Right/Left]most()

Οι λειτουργίες addKey() και deleteKey() επαναγράφτηκαν ώστε να χειρίζονται
με σωστό τρόπο τα πεδία των threads. Για τις υλοποιήσεις των βασικών αυτών λειτουργιών
συμβουλεύτηκα το geeksforgeeks και για τις δυο κλάσεις.

Τέλος, η αναζήτηση πεδίων τιμών γράφτηκε απο την αρχή προκειμένου να μην 
είναι αναδρομική ουτε να χρησιμοποιεί στοίβα, πράγμα που μπορούσε πλέον
να συμβεί με την βοήθεια της inorderSucc().

ΓΙΑ ΤΙΣ ΜΕΤΡΗΣΕΙΣ ΣΕ ΟΛΕΣ ΤΙΣ ΚΛΑΣΕΙΣ ΥΛΟΠΟΙΗΣΑ ΤΙΣ ΣΥΝΑΡΤΗΣΕΙΣ
resetCompares() = επιστρέφει στο μηδεν το μετρητη
incrCompares() = αυξάνει το μετρητη κατα την επιθυμητή τιμη
getCompares() = επιστρέφει την τιμή του μετρητή

Μετρήθηκαν όλες οι αναθέσεις τιμών και όλες οι συγκρίσεις στις συναρτήσεις που
αφορούν τα αποτελέσματα.
ΕΚΤΟΣ ΑΥΤΟΥ μετρήθηκαν όλα τα περάσματα ορισμάτων σε συνάρτηση, 
και οι επιστροφές τιμών απο συνάρτηση, μιας και αποτελούν αναθέσεις.


ΕΡΜΗΝΕΙΑ ΤΩΝ ΑΠΟΤΕΛΕΣΜΑΤΩΝ:


--INSERTION STATISTICS--
BST: 50 comparisons per insertion
Threaded BST: 54 comparisons per insertion

Για την εισαγωγή τιμών στο δένδρο, περιμένουμε τα βήματα να είναι ανάλογα του
υψους του δένδρου σε κάθε εισαγωγή. Αρα να έχουμε μια τιμή ~ k*log(n) ~ όπου n
ο αριθμός κλειδιών του δένδρου. Το k είναι μια σταθερά που έχει να κάνει με το
πόσες 'συγκρισεις' γίνονται κάθε φορά που κατεβαίνουμε ένα επίπεδο στο δένδρο, 
η ακριβής τιμή του δεν έχει σημασία.

Αυτό που είναι ενδιαφέρον, είναι οτι το Threaded BST για τις ιδιες εισαγωγές κλειδιών
έχει ακριβώς 4 περισσότερες συγκρίσεις απο το BST. Αυτό συμβαίνει επειδή η αναζήτηση
δεν διαφέρει καθόλου ανάμεσα στις δυο υλοποιήσεις, το μόνο που αλλάζει είναι οι έξτρα 4
αναθέσεις για τον ορισμό του πεδίου LEFT_THREAD και RIGHT_THREAD και την σωστή απόδοση τιμών του.


--SEARCH STATISTICS--
BST: 133 comparisons per search
Threaded BST: 133 comparisons per search
Sorted Array: 115 comparisons per search

Η αναζήτηση τιμών έχει και αυτή λογαριθμική πολυπλοκότητα, άρα περιμένουμε k*log(n) βήματα
όπως και παραπάνω. Επειδή ούτε η αναζήτηση αλλάζει στην υλοποίηση του Threaded BST, περιμένουμε
σε κάθε εκτέλεση τον ίδιο ακριβώς αριθμό βημάτων.

Γνωρίζουμε οτι τα δέντρα δεν είναι απαραίτητο να είναι καλοισοζυγισμένα, επομένος το ύψος μπορεί
να μην είναι πάντα ανάλογο του log(n). Πρακτικά όμως για μεγάλο αριθμό τυχαίων κλειδιών, τα δένδρα
ισορροπούν σχετικά καλά με συντριπτική πιθανότητα, δίνοντας Ο(logn) στην αναζήτηση.

Ο ταξινομιμένος πίνακας δίνει καλύτερο αποτέλεσμα, αφού ο αλγόριθμος binarySearch, χωρίζει σε
κάθε βήμα το διάστημα ακριβώς στην μέση [εκτός μονών διαστημάτων, αλλα μικρό το κακό]. Έτσι έχει
πανομοιότυπη συμπεριφορά με ένα τέλεια ισοζυγισμένο δέντρο. Οι ατέλειες των πάνω δέντρων που
ανέφερα προηγουμένως δημιουργούν αυτό το μικρό χάσμα στις 'συγκρισεις'


--SEARCH RANGE WITH K = 100 STATISTICS--
BST: 211 comparisons per search
Threaded BST: 104 comparisons per search
Sorted Array: 135 comparisons per search

--SEARCH RANGE WITH K = 1000 STATISTICS--
BST: 1038 comparisons per search
Threaded BST: 840 comparisons per search
Sorted Array: 319 comparisons per search

Σε αυτή την αναζήτηση, είναι σημαντικό να θυμηθούμε οτι οι δομές περιέχουν
10^5 κλειδια απο τις 10^6 πιθανές ακέραιες τιμες. Επομένως ένα διάστημα Κ θα
δώσει το ένα δέκατο του εύρους του σε κλειδιά.
Το Κ = 100 θα βρίσκει κατα μεσο όρο 10 κλειδιά
και το Κ = 1000 θα βρίσκει 100 κλειδιά

Οι δυο υλοποιήσεις έχουν εντελώς ξεχωριστό τρόπο αναζήτησης κλειδιών, με τα πλεονεκτήματα
και τα μειωνεκτηματα τους.

Αρχικά το BST χρησιμοποιεί αναδρομή για την εύρεση διαστήματος. Με αυτόν τον τρόπο,
αναπόφευκτα θα επισκευθεί μερικούς κόμβους που βρίσκονται εκτός, τοσο στα 
δεξια οσο και στα αριστερά του διαστήματος. Θα επισκευθεί με αναδρομή όλους τους κόμβους
που ανήκουν στο διάστημα.

Το Threaded BST χρησιμοποιεί διαφορετική λογική. Αρχικά βρίσκει με επαναληπτικό τρόπο τον 
πρώτο κόμβο του διαστήματος, και έπειτα τους επόμενους με την βοήθεια της inorderSucc. Η 
περιορισμένη χρήση της στοίβας (που είναι πολύ ακριβή σε αναθέσεις) καθιστά αυτόν τον τρόπο
πιο αποτελεσματικό. Σε πρώτη ανάγνωση η απόδοση φαίνεται να είναι διπλάσια. 
Όμως η συνάρτηση inorderSucc(node), όταν το node έχει δεξι παιδί, παράγει τα
αποτελέσματα με χρήση της getLeftmost(), πράγμα που αναγκάζει τον αλγόριθμο τελικά
να επισκευθεί μερικούς κόμβους δυο φορές. Η δεύτερη υλοποίηση καταλήγει να έχει
περισσοτερες πραγματικες συγκρίσεις απο την αναδρομική [ειδικότερα λόγω διπλής σύγκρισης του == -1],

Ετσι συνηπολογίζοντας αυτόν τον παράγοντα, και για πολυ μεγάλες τιμές του Κ ( >> 10000) καταλήγει 
πειραματικά ο λόγος της απόδοσης να ειναι πιο κοντα στο 1.125 υπέρ της Threaded υλοποίησης.

Γνωρίζοντας οτι στην πραγματικότητα η δημιουργία stack frames είναι ακόμη πιο βαριά απο τις 
μετρήσεις μας σε 'συγκρίσεις', καταλήγουμε οτι η δεύτερη υλοποίηση υπερτερεί.
Σε πιο ελεύθερες υλοποιήσεις ο extra χώρος που απαιτεί ένα Threaded BST είναι ελάχιστος (2 extra bits per node)
και οι πράξεις της εισαγωγής και της διαγραφής γίνονται πρακτικά με ίδια βήματα με το BST.




Φυσικά παρατηρούμε οτι και στις 2 περιπτώσεις [Κ = 100, 1000] η υλοποίηση με Ταξινομιμένο πίνακα κυριαρχεί.
Στη λογική της δεύτερης υλοποίησης, ο πίνακας βρίσκει το πρώτο κλειδί εντός διαστήματος με
binary search και επισκέπτεται τα υπόλοιπα με γραμμική διάσχηση.
Οι 'συγκρίσεις' αυτής της μεθόδου είναι περιορισμένες επειδή η γραμμική διάσχηση σε πίνακα
ειναι απλή και δεν οδηγεί σε διπλή επίσκεψη κανενός κελιού. Επίσης οι τιμές εκτός διαστήματος
που αναπόφευκτα μπορεί να επισκευθεί ο αλγόριθμος περιορίζονται σε 2 [μια στην αρχη και μια στο τελος
του διαστήματος]

ΑΛΛΑ!!
Η χρήση ταξινομημένου πίνακα ΔΕΝ ΕΝΔΕΙΚΝΥΤΑΙ σε καμια περίπτωση για συστήματα με πολλές εισαγωγές
Η εισαγωγή τιμών είναι πολύ αργή διαδικασία Ο(n) και η πολυπλοκότητα του αλγορίθμου αναζήτησης διαστήματος
δεν έχει θεωρητική βελτίωση. Επομένως, οι δενδρικές υλοποιήσεις αποτελούν καλύτερο tradeoff στις περισότερες
των περιπτώσεων.



